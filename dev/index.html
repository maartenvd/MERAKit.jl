<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MERA.jl reference · MERA.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MERA.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>MERA.jl reference</a><ul class="internal"><li><a class="tocitem" href="#MERA-types"><span>MERA types</span></a></li><li><a class="tocitem" href="#Layer-types"><span>Layer types</span></a></li><li><a class="tocitem" href="#Utility-functions"><span>Utility functions</span></a></li><li><a class="tocitem" href="#Generating-and-modifying-MERAs"><span>Generating and modifying MERAs</span></a></li><li><a class="tocitem" href="#Measuring-physical-quantities"><span>Measuring physical quantities</span></a></li><li><a class="tocitem" href="#Ascending-operators"><span>Ascending operators</span></a></li><li><a class="tocitem" href="#Descending-density-matrices"><span>Descending density matrices</span></a></li><li><a class="tocitem" href="#Optimizing-a-MERA"><span>Optimizing a MERA</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>MERA.jl reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MERA.jl reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mhauru/MERA.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MERA.jl-reference"><a class="docs-heading-anchor" href="#MERA.jl-reference">MERA.jl reference</a><a id="MERA.jl-reference-1"></a><a class="docs-heading-anchor-permalink" href="#MERA.jl-reference" title="Permalink"></a></h1><p>MERA.jl provides Julia implementations of some basic <a href="https://arxiv.org/abs/quant-ph/0610099">Multiscale Entaglement Renormalization Ansatz</a> algorithms. For usage instructions, see the <a href="https://github.com/mhauru/MERA.jl">GitHub page</a>. Below you can find the reference documentation, listing all the types and functions.</p><h2 id="MERA-types"><a class="docs-heading-anchor" href="#MERA-types">MERA types</a><a id="MERA-types-1"></a><a class="docs-heading-anchor-permalink" href="#MERA-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MERA.GenericMERA" href="#MERA.GenericMERA"><code>MERA.GenericMERA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GenericMERA{N, LT &lt;: Layer, OT}</code></pre><p>A <code>GenericMERA</code> is a collection of <code>Layer</code>s. The type of these layers then determines whether the MERA is binary, ternary, etc.</p><p>On conventions and terminology:</p><ul><li>The physical indices of the MERA are at the &quot;bottom&quot;, the scale invariant part at the &quot;top&quot;.</li><li>The counting of layers starts from the bottom, so the layer with physical indices is layer 1. The last layer is the scale invariant one, that then repeats upwards to infinity.</li><li>Each layer is thought of as a linear map from its top, or input space to its bottom, or output space.</li></ul><p>The type parameters are <code>N</code>:  The number of distinct layers (N-1 transition layers and one scale invariant one). <code>LT</code>: Layer type. <code>OT</code>: Operator type. The type of ascended and descended operators for this MERA. Determined       from <code>LT</code>. Typically a <code>TensorMap</code> with input and output indices matching the causal       cone width.</p><p><code>GenericMERA</code> is immutable, and the layers can not be changed after construction. All functions that modify a <code>GenericMERA</code> return new objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L7-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.TernaryMERA" href="#MERA.TernaryMERA"><code>MERA.TernaryMERA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TernaryMERA{N}</code></pre><p>A ternary MERA is a MERA consisting of <code>TernaryLayer</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/ternarylayer.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.BinaryMERA" href="#MERA.BinaryMERA"><code>MERA.BinaryMERA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BinaryMERA{N}</code></pre><p>A binary MERA is a MERA consisting of <code>BinaryLayer</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/binarylayer.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.ModifiedBinaryMERA" href="#MERA.ModifiedBinaryMERA"><code>MERA.ModifiedBinaryMERA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ModifiedBinaryMERA{N}</code></pre><p>A modified binary MERA is a MERA consisting of <code>ModifiedBinaryLayer</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/modifiedbinarylayer.jl#L98-L102">source</a></section></article><h2 id="Layer-types"><a class="docs-heading-anchor" href="#Layer-types">Layer types</a><a id="Layer-types-1"></a><a class="docs-heading-anchor-permalink" href="#Layer-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MERA.Layer" href="#MERA.Layer"><code>MERA.Layer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract supertype of all layer types, e.g. <code>BinaryLayer</code> and <code>TernaryLayer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/layer.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.SimpleLayer" href="#MERA.SimpleLayer"><code>MERA.SimpleLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimpleLayer &lt;: Layer</code></pre><p>A <code>SimpleLayer</code> is a MERA layer that consists of a set of isometries and/or unitaries, and nothing else. This allows writing convenient generic versions of many methods, reducing code duplication for the concrete <code>Layer</code> types. Every subtype of <code>SimpleLayer</code> should implement the iteration and indexing interfaces to return the various tensors of the layer in the same order in which the constructor takes them in.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/simplelayer.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.TernaryLayer" href="#MERA.TernaryLayer"><code>MERA.TernaryLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TernaryLayer{ST, ET, Tan} &lt;: SimpleLayer</code></pre><p>The type for layers of a ternary MERA.</p><p>Each layer consists of two tensors, a 2-to-2 disentangler, often called <code>u</code>, and a 3-to-1 isometry, often called <code>w</code>.</p><p>The type parameters are <code>ST</code> for space type, e.g. <code>ComplexSpace</code> or <code>SU2Space</code>; <code>ET</code> for element type, e.g. <code>Complex{Float64}</code>; and <code>Tan</code> for whether this layer is a tangent layer or not.  If <code>Tan = false</code>, the layer is question is an actual MERA layer. If <code>Tan = true</code> it consists, instead of the actual tensors, of Stiefel/Grassmann tangent vectors of these tensors.</p><p>Index numbering convention is as follows, where the physical indices are at the bottom: Disentangler:</p><pre><code class="language-none"> 3|   4|
 +------+
 |  u   |
 +------+
 1|   2|</code></pre><p>Isometry:</p><pre><code class="language-none">    4|
 +-------+
 |   w   |
 +-------+
 1| 2| 3|</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/ternarylayer.jl#L4-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.BinaryLayer" href="#MERA.BinaryLayer"><code>MERA.BinaryLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BinaryLayer{ST, ET, Tan} &lt;: SimpleLayer</code></pre><p>The type for layers of a binary MERA.</p><p>Each layer consists of two tensors, a 2-to-2 disentangler, often called <code>u</code>, and a 2-to-1 isometry, often called <code>w</code>.</p><p>The type parameters are <code>ST</code> for space type, e.g. <code>ComplexSpace</code> or <code>SU2Space</code>; <code>ET</code> for element type, e.g. <code>Complex{Float64}</code>; and <code>Tan</code> for whether this layer is a tangent layer or not.  If <code>Tan = false</code>, the layer is question is an actual MERA layer. If <code>Tan = true</code> it consists, instead of the actual tensors, of Stiefel/Grassmann tangent vectors of these tensors.</p><p>Index numbering convention is as follows, where the physical indices are at the bottom: Disentangler:</p><pre><code class="language-none"> 3|   4|
 +------+
 |  u   |
 +------+
 1|   2|</code></pre><p>Isometry:</p><pre><code class="language-none">   3|
 +------+
 |  w   |
 +------+
 1|   2|</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/binarylayer.jl#L4-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.ModifiedBinaryLayer" href="#MERA.ModifiedBinaryLayer"><code>MERA.ModifiedBinaryLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ModifiedBinaryLayer{ST, ET, Tan} &lt;: SimpleLayer</code></pre><p>The type for layers of a modified binary MERA.</p><p>Each layer consists of three tensors, a 2-to-2 disentangler, often called <code>u</code>, and two 2-to-1 isometries, often called <code>wl</code> and <code>wr</code>, for left and right. Their relative locations are</p><pre><code class="language-none">|     |
wl   wr
| \ / |
|  u  |
| / \ |</code></pre><p>The type parameters are <code>ST</code> for space type, e.g. <code>ComplexSpace</code> or <code>SU2Space</code>; <code>ET</code> for element type, e.g. <code>Complex{Float64}</code>; and <code>Tan</code> for whether this layer is a tangent layer or not.  If <code>Tan = false</code>, the layer is question is an actual MERA layer. If <code>Tan = true</code> it consists, instead of the actual tensors, of Stiefel/Grassmann tangent vectors of these tensors.</p><p>Index numbering convention is as follows, where the physical indices are at the bottom: Disentangler:</p><pre><code class="language-none"> 3|   4|
 +------+
 |  u   |
 +------+
 1|   2|</code></pre><p>Isometries:</p><pre><code class="language-none">   3|
 +------+
 |  w   |
 +------+
 1|   2|</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/modifiedbinarylayer.jl#L4-L44">source</a></section></article><h2 id="Utility-functions"><a class="docs-heading-anchor" href="#Utility-functions">Utility functions</a><a id="Utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MERA.num_translayers" href="#MERA.num_translayers"><code>MERA.num_translayers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">num_translayers(m::GenericMERA)</code></pre><p>Return the number of transition layers, i.e. layers below the scale invariant one, in the MERA.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L135-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.layertype" href="#MERA.layertype"><code>MERA.layertype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">layertype(m::GenericMERA)
layertype(::Type{&lt;:GenericMERA})</code></pre><p>Return the type of the layers of the MERA.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L86-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.operatortype" href="#MERA.operatortype"><code>MERA.operatortype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">operatortype(m::GenericMERA)
operatortype(::Type{&lt;: GenericMERA})</code></pre><p>Return the type of operator associate with this MERA or MERA type. That means the type of operator that fits in the causal cone, and is naturally emerges as one ascends local operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L104-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.scalefactor" href="#MERA.scalefactor"><code>MERA.scalefactor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scalefactor(::Type{&lt;: GenericMERA})</code></pre><p>The ratio by which the number of sites changes when one descends by one layer, e.g. 2 for binary MERA, 3 for ternary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.causal_cone_width" href="#MERA.causal_cone_width"><code>MERA.causal_cone_width</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">causal_cone_width(::Type{&lt;: GenericMERA})</code></pre><p>Return the width of the stable causal cone for this MERA type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.get_layer" href="#MERA.get_layer"><code>MERA.get_layer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_layer(m::GenericMERA, depth)</code></pre><p>Return the layer at the given depth. 1 is the lowest layer, i.e. the one with physical indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L144-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.outputspace" href="#MERA.outputspace"><code>MERA.outputspace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">outputspace(layer::Layer)</code></pre><p>Return the vector space of the downwards-pointing (towards the physical level) indices of `layer.</p><p>See also: <a href="#MERA.inputspace"><code>inputspace</code></a>, <a href="#MERA.internalspace"><code>internalspace</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/layer.jl#L34-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.inputspace" href="#MERA.inputspace"><code>MERA.inputspace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">inputspace(layer::Layer)</code></pre><p>Return the vector space of the upwards-pointing (towards the scale invariance) indices of `layer.</p><p>See also: <a href="#MERA.outputspace"><code>outputspace</code></a>, <a href="#MERA.internalspace"><code>internalspace</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/layer.jl#L44-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.internalspace" href="#MERA.internalspace"><code>MERA.internalspace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">internalspace(layer::Layer)</code></pre><p>Return the internal vector space of `layer.</p><p>See also: <a href="#MERA.outputspace"><code>outputspace</code></a>,  <a href="#MERA.inputspace"><code>inputspace</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/layer.jl#L54-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.pseudoserialize" href="#MERA.pseudoserialize"><code>MERA.pseudoserialize</code></a> — <span class="docstring-category">Function</span></header><section><div><p>pseudoserialize(x)</p><p>Return a tuple of objects that can be used to reconstruct <code>x</code>, and that are all of Julia base types.</p><p>The name refers to how this isn&#39;t quite serialization, since it doesn&#39;t break objects down to bit strings, but kinda serves the same purpose: pseudoserialised objects can easily be written and read from e.g. disk, without having to worry about quirks of the type system (like with JLD).</p><p>See also: <a href="#MERA.depseudoserialize"><code>depseudoserialize</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L353-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.depseudoserialize" href="#MERA.depseudoserialize"><code>MERA.depseudoserialize</code></a> — <span class="docstring-category">Function</span></header><section><div><p>depseudoserialize(::Type{T}, args) where T &lt;: GenericMERA</p><p>Reconstruct an object given the output of <code>pseudoserialize</code>: <code>x -&gt; depseudoserialize(pseudoserialize(x)...)</code> should be an effective noop.</p><p>See also: <a href="#MERA.pseudoserialize"><code>pseudoserialize</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L370-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.remove_symmetry" href="#MERA.remove_symmetry"><code>MERA.remove_symmetry</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remove_symmetry(V)</code></pre><p>Strip a vector space of its symmetry structure, i.e. return the corresponding <code>ℂ^n</code> or <code>ℝ^n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/tensortools.jl#L152-L157">source</a></section><section><div><pre><code class="language-none">remove_symmetry(t::AbstractTensorMap)</code></pre><p>Strip an <code>AbstractTensorMap</code> of its internal symmetries, and return the corresponding <code>TensorMap</code> that operators on <code>ComplexSpace</code> or <code>CartesianSpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/tensortools.jl#L161-L166">source</a></section><section><div><pre><code class="language-none">remove_symmetry(m::GenericMERA)</code></pre><p>Given a MERA which may possibly be built of symmetry preserving <code>TensorMap</code>s, return another, equivalent MERA that has the symmetry structure stripped from it, and all tensors are dense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L337-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKitManifolds.projectisometric" href="#TensorKitManifolds.projectisometric"><code>TensorKitManifolds.projectisometric</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">projectisometric(m::GenericMERA)</code></pre><p>Project all the tensors of the MERA to respect the isometricity condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L183-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKitManifolds.projectisometric!" href="#TensorKitManifolds.projectisometric!"><code>TensorKitManifolds.projectisometric!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">projectisometric!(m::GenericMERA)</code></pre><p>Project all the tensors of the MERA to respect the isometricity condition, in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L192-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.reset_storage" href="#MERA.reset_storage"><code>MERA.reset_storage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reset_storage(m::GenericMERA)</code></pre><p>Reset cached operators, so that they will be recomputed when they are needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L231-L235">source</a></section></article><h2 id="Generating-and-modifying-MERAs"><a class="docs-heading-anchor" href="#Generating-and-modifying-MERAs">Generating and modifying MERAs</a><a id="Generating-and-modifying-MERAs-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-and-modifying-MERAs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MERA.replace_layer" href="#MERA.replace_layer"><code>MERA.replace_layer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">replace_layer(c::MERACache, depth)</code></pre><p>Create a new <code>MERACache</code> that has all the stored pieces removed that are invalidated by changing the layer at <code>depth</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/meracache.jl#L87-L92">source</a></section><section><div><pre><code class="language-none">replace_layer(m::GenericMERA, layer, depth; check_invar=true)</code></pre><p>Replace <code>depth</code> layer of <code>m</code> with <code>layer</code>. If check_invar=true, check that the indices match afterwards.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L154-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.release_transitionlayer" href="#MERA.release_transitionlayer"><code>MERA.release_transitionlayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">release_transitionlayer(m::GenericMERA)</code></pre><p>Add one more transition layer at the top of the MERA, by taking the lowest of the scale invariant ones and releasing it to vary independently.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L170-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.random_MERA" href="#MERA.random_MERA"><code>MERA.random_MERA</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_MERA(::Type{T &lt;: GenericMERA}, ET, Vouts, Vints=Vouts; kwargs...)</code></pre><p>Generate a random MERA of type <code>T</code>.</p><p><code>ET</code> is the element type of the MERA, e.g. <code>Float64</code>. <code>Vouts</code> are the vector spaces between the various layers. Number of layers will be the length of <code>Vouts</code>. <code>Vouts[1]</code> will be the physical index space, and <code>Vs[end]</code> will be the one at the scale invariant layer. <code>Vints</code> can be a vector/tuple of the same length as <code>Vouts</code>, and include vector spaces for the internal indices of each layer. Alternatively, it can hold any other extra parameters specific to each layer, as it is simply passed on to the function <code>randomlayer</code>. Also passed to <code>randomlayer</code> will be any additional keyword arguments, but these will all be the same for each layer.</p><p>See also: <a href="#MERA.randomlayer"><code>randomlayer</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L240-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.randomlayer" href="#MERA.randomlayer"><code>MERA.randomlayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randomlayer(::Type{T &lt;: Layer}, T, Vin, Vout, Vint=Vout; random_disentangler=false)</code></pre><p>Return a MERA layer with random tensors.</p><p><code>T</code> is the <code>Layer</code> type, and <code>Vin</code> and <code>Vout</code> are the input and output spaces. <code>Vint</code> is an internal vector space for the layer, connecting the disentanglers to the isometries. If <code>random_disentangler=true</code>, the disentangler is also a random unitary, if <code>false</code> (default), it is the identity or the product of two single-site isometries, depending on if the disentanler is supposed to be unitary or isometric.</p><p>Each subtype of <code>Layer</code> should have its own method for this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/layer.jl#L19-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.expand_bonddim" href="#MERA.expand_bonddim"><code>MERA.expand_bonddim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand_bonddim(m::GenericMERA, depth, newdims; check_invar=true)</code></pre><p>Expand the bond dimension of the MERA at the given depth.</p><p>The indices to expand are the input indices of the layer at <code>depth</code>, i.e. <code>depth=1</code> means the lowest virtual indices. The new bond dimension is given by <code>newdims</code>, which for a non-symmetric MERA is just a number, and for a symmetric MERA is a dictionary of <code>irrep =&gt; block dimension</code>. Not all irreps for a bond need to be listed, the ones left out are left untouched.</p><p>The expansion is done by padding tensors with zeros. Note that this breaks isometricity of the individual tensors. This is however of no consequence, since the MERA as a state remains exactly the same. A round of optimization on the MERA will restore isometricity of each tensor, or <code>projectisometric</code> can be called to do so explicitly.</p><p>If <code>check_invar = true</code> the function checks that the bond dimensions of various layers match after the expansion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L269-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.expand_internal_bonddim" href="#MERA.expand_internal_bonddim"><code>MERA.expand_internal_bonddim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand_internal_bonddim(m::GenericMERA, depth, newdims; check_invar=true)</code></pre><p>Expand the bond dimension of the layer-internal indices of the MERA at the given depth.</p><p>The new bond dimension is given by <code>newdims</code>, which for a non-symmetric MERA is just a number, and for a symmetric MERA is a dictionary of {irrep =&gt; block dimension}. Not all irreps for a bond need to be listed, the ones left out are left untouched.</p><p>The expansion is done by padding tensors with zeros. Note that this breaks isometricity of the individual tensors. This is however of no consequence, since the MERA as a state remains exactly the same. A round of optimization on the MERA will restore isometricity of each tensor, or <code>projectisometric</code> can be called to do so explicitly.</p><p>Note that not all MERAs have an internal bond dimension, and some may have several, so this function will not make sense for all MERA types. Implementation relies on the function <code>expand_internalspace</code>, defined for each <code>Layer</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L310-L327">source</a></section></article><h2 id="Measuring-physical-quantities"><a class="docs-heading-anchor" href="#Measuring-physical-quantities">Measuring physical quantities</a><a id="Measuring-physical-quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Measuring-physical-quantities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MERA.expect" href="#MERA.expect"><code>MERA.expect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expect(op, m::GenericMERA, pars=(;), opscale=1, evalscale=1)</code></pre><p>Return the expecation value of operator <code>op</code> for the MERA <code>m</code>.</p><p>The layer on which <code>op</code> lives is set by <code>opscale</code>, which by default is the physical one. <code>evalscale</code> can be used to set whether the operator is ascended through the network or the density matrix is descended. <code>pars</code> can hold additional options that are further down the line passed on to <code>fixedpoint_densitymatrix</code>.</p><p>See also: <a href="#MERA.fixedpoint_densitymatrix"><code>fixedpoint_densitymatrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L708-L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.scalingdimensions" href="#MERA.scalingdimensions"><code>MERA.scalingdimensions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scalingdimensions(m::GenericMERA, howmany=20)</code></pre><p>Diagonalize the scale invariant ascending superoperator to compute the scaling dimensions of the underlying CFT.</p><p>The return value is a dictionary, the keys of which are symmetry sectors for a possible internal symmetry of the MERA (Trivial() if there is no internal symmetry), and values are scaling dimensions in this symmetry sector.</p><p><code>howmany</code> controls how many of lowest scaling dimensions are computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L667-L678">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.densitymatrix_entropies" href="#MERA.densitymatrix_entropies"><code>MERA.densitymatrix_entropies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">densitymatrix_entropies(m::GenericMERA)</code></pre><p>Return a vector of entropies for the density matrices in the MERA. The first one is for the density matrix at the physical level, the last one is the scale invariant density matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L221-L226">source</a></section></article><h2 id="Ascending-operators"><a class="docs-heading-anchor" href="#Ascending-operators">Ascending operators</a><a id="Ascending-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Ascending-operators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MERA.ascend" href="#MERA.ascend"><code>MERA.ascend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ascend(op, layer::Layer)</code></pre><p>Ascend a local operator <code>op</code> from the bottom of <code>layer</code> to the top.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/layer.jl#L126-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.ascended_operator" href="#MERA.ascended_operator"><code>MERA.ascended_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ascended_operator(m::GenericMERA, op, depth)</code></pre><p>Return the operator <code>op</code> ascended from the physical level to <code>depth</code>.</p><p>This function utilises the cache, to avoid recomputation.</p><p>See also: <a href="#MERA.scale_invariant_operator_sum"><code>scale_invariant_operator_sum</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L559-L567">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.scale_invariant_operator_sum" href="#MERA.scale_invariant_operator_sum"><code>MERA.scale_invariant_operator_sum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scale_invariant_operator_sum(m::GenericMERA, op, pars)</code></pre><p>Return the sum of the ascended versions of <code>op</code> in the scale invariant part of the MERA.</p><p>To be more precise, this sum is of course infinite, and what we return is the component of it orthogonal to the dominant eigenoperator of the ascending superoperator (typically the identity). This component converges to a finite result like a geometric series, since all non-dominant eigenvalues of the ascending superoperator are smaller than 1.</p><p>To approximate the converging series, we use an iterative Krylov solver. The options for the solver should be in <code>pars.scaleinvariant_krylovoptions</code>, they will be passed to <code>KrylovKit.linsolve</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L580-L593">source</a></section></article><h2 id="Descending-density-matrices"><a class="docs-heading-anchor" href="#Descending-density-matrices">Descending density matrices</a><a id="Descending-density-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Descending-density-matrices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MERA.descend" href="#MERA.descend"><code>MERA.descend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">descend(rho, layer::Layer)</code></pre><p>Descend a local density matrix <code>rho</code> from the top of <code>layer</code> to the bottom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/layer.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.densitymatrix" href="#MERA.densitymatrix"><code>MERA.densitymatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">densitymatrix(m::GenericMERA, depth, pars=(;))</code></pre><p>Return the density matrix right below the layer at <code>depth</code>.</p><p><code>pars</code> maybe a <code>NamedTuple</code> of options, passed on to the function <code>fixedpoint_densitymatrix</code>.</p><p>This function utilises the cache, to avoid recomputation.</p><p>See also: <a href="#MERA.fixedpoint_densitymatrix"><code>fixedpoint_densitymatrix</code></a>, <a href="#MERA.densitymatrices"><code>densitymatrices</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L516-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.densitymatrices" href="#MERA.densitymatrices"><code>MERA.densitymatrices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">densitymatrices(m::GenericMERA, pars=(;))</code></pre><p>Return all the distinct density matrices of the MERA, starting with the one at the physical level, and ending with the scale invariant one.</p><p><code>pars</code> maybe a <code>NamedTuple</code> of options, passed on to the function <code>fixedpoint_densitymatrix</code>.</p><p>See also: <a href="#MERA.fixedpoint_densitymatrix"><code>fixedpoint_densitymatrix</code></a>, <a href="#MERA.densitymatrix"><code>densitymatrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L543-L553">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.fixedpoint_densitymatrix" href="#MERA.fixedpoint_densitymatrix"><code>MERA.fixedpoint_densitymatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fixedpoint_densitymatrix(m::GenericMERA, pars::NamedTuple=(;))</code></pre><p>Find the fixed point density matrix of the scale invariant part of the MERA.</p><p>To find the fixed point, we use an iterative Krylov solver. The options for the solver should be in <code>pars.scaleinvariant_krylovoptions</code>, they will be passed to <code>KrylovKit.eigsolve</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L470-L478">source</a></section></article><h2 id="Optimizing-a-MERA"><a class="docs-heading-anchor" href="#Optimizing-a-MERA">Optimizing a MERA</a><a id="Optimizing-a-MERA-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing-a-MERA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MERA.minimize_expectation" href="#MERA.minimize_expectation"><code>MERA.minimize_expectation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minimize_expectation(m::GenericMERA, h, pars=(;);
                     finalize! = OptimKit._finalize!, vary_disentanglers=true,
                     kwargs...)</code></pre><p>Return a MERA optimized to minimize the expectation value of operator <code>h</code>, starting with <code>m</code> as the initial guess.</p><p><code>pars</code> is a <code>NamedTuple</code> of parameters for the optimisation. They are,</p><ul><li><code>method</code>: A <code>Symbol</code> that chooses which optimisation method to use. Options are <code>:lbfgs</code> for L-BFGS (default), <code>:ev</code> for Evenbly-Vidal, <code>:cg</code> for conjugate gradient, and <code>:gd</code> for gradient descent. <code>:lbfgs</code>, <code>:cg</code>, and <code>:gd</code> are together known as the gradient methods.</li><li><code>maxiter</code>: Maximum number of iterations to use. 2000 by default.</li><li><code>gradient_delta</code>: Convergence threshold, as measured by the norm of the gradient. <code>1e-14</code> by default.</li><li><code>precondition</code>: Whether to apply preconditioning with the physical Hilbert space inner product. <code>true</code> by default. See https://arxiv.org/abs/2007.03638 for more details.</li><li><code>verbosity</code>: How much output to log. 2 by default.</li><li><code>isometries_only_iters</code>: An integer for how many iterations should at first be done optimising only the isometries, and leaving the disentangler be. 0 by default.</li><li><code>scaleinvariant_krylovoptions</code>: A <code>NamedTuple</code> of keyword arguments passed to <code>KrylovKit.linsolve</code> and <code>KrylovKit.eigsolve</code>, when solving for the fixed-point density matrix and the scale invariant operator sum. The default is <code>(tol = 1e-13, verbosity = 0, maxiter = 20)</code>.</li><li><code>retraction</code>: Which retraction method to use. Options are <code>:exp</code> for geodesics (default), and <code>:cayley</code> for Cayley transforms. Only affects gradient methods.</li><li>transport: Which vector transport method to use. Currently each retraction<code>method only comes with a single compatible transport, so one should always use</code>transport<code>to be the same as</code>retraction`. This may change. Only affects gradient methods.</li><li><code>metric</code>: Which metric to use for Stiefel manifold. Options are <code>:euclidean</code> (default) and <code>:canonical</code>. Only affects gradient methods.</li><li><code>ls_epsilon</code>: The ϵ parameter for the Hager-Zhang line search. <code>1e-6</code> be default. Only affects gradient methods.</li><li><code>lbfgs_m</code>: The rank of the approximation of the inverse Hessian in L-BFGS. 8 by default. Only affects the <code>:lbfgs</code> method.</li><li><code>cg_flavor</code>: The &quot;flavor&quot; of conjguate gradient to use. <code>:HagerZhang</code> by default. Only affects the <code>:cg:</code> method.</li><li><code>ev_layer_iters</code>: How many times a single layer is optimised before moving to the next layer in the Evenbly-Vidal algorithm. <code>1</code> by default. Only affects the <code>:ev</code> method.</li></ul><p>If any of these are specified in <code>pars</code>, the specified values override the defaults.</p><p><code>finalize!</code> is a function that will be called at every iteration. It can be used to for instance log the development of some quantity during the optimisation, or modify the MERA in some custom (although undefined behavior may follow depending on how the state is changed). Its signature is <code>finalize!(m, f, g, counter)</code> where <code>m</code> is the current MERA, <code>f</code> is its expectation value for <code>h</code>, <code>g</code> is the gradient MERA at <code>m</code>, and <code>counter</code> is the current iteration number. It should return the possibly modified <code>m</code>, <code>f</code>, and <code>g</code>. If <code>method = :ev</code>, then it should also be able to handle the case <code>g = nothing</code>, since the Evenbly-Vidal algorithm does not use gradients.</p><p><code>vary_disentanglers</code> gives the option of running the optimisation but only for the isometries, leaving the disentanglers as they are.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L753-L805">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.environment" href="#MERA.environment"><code>MERA.environment</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">environment(layer::Layer, op, rho; vary_disentanglers=true)</code></pre><p>Compute the environments with respect to <code>op</code> of all the tensors in the layer, and return them as a <code>Layer</code>. <code>rho</code> is the local density matrix at the top indices of this layer.</p><p>If <code>vary_disentanglers=false</code>, only compute the environments for the isometries, and set the environments for the disentanglers to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/layer.jl#L139-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.gradient" href="#MERA.gradient"><code>MERA.gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gradient(h, m::GenericMERA, pars::NamedTuple; vary_disentanglers=true)</code></pre><p>Compute the gradient of the expectation value of <code>h</code> at the point <code>m</code>.</p><p><code>pars</code> should have <code>pars.metric</code> that specifies whether to use the <code>:euclidean</code> or <code>:canonical</code> metric for the Stiefel manifold, and <code>pars.scaleinvariant_krylovoptions</code> that is passed on to <a href="#MERA.environment"><code>environment</code></a>.</p><p><code>vary_disentanglers</code> allows computing the gradients only for the isometries, and setting the gradients for the disentanglers to zero.</p><p>The return value is a &quot;tangent MERA&quot;: An object of a similar type as <code>m</code>, but instead of regular layers with tensors that have isometricity constraints, instead each layer holds the corresponding gradients for each tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L953-L968">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKitManifolds.retract" href="#TensorKitManifolds.retract"><code>TensorKitManifolds.retract</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">retract(m::GenericMERA, mtan::GenericMERA, alpha::Real; kwargs...)</code></pre><p>Given a &quot;tangent MERA&quot; <code>mtan</code>, at base point <code>m</code>, retract in the direction of <code>mtan</code> by distance <code>alpha</code>. This is done tensor-by-tensor, i.e. each tensor is retracted along its respective Stiefel/Grassmann tangent.</p><p>The additional keyword argument are passed on to the respective <code>TensorKitManifolds</code> function.</p><p>See <code>TensorKitManifolds.retract</code> for more details.</p><p>See also: <a href="#TensorKitManifolds.transport!"><code>transport!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L1002-L1015">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKitManifolds.transport!" href="#TensorKitManifolds.transport!"><code>TensorKitManifolds.transport!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transport!(mvec::GenericMERA, m::GenericMERA, mtan::GenericMERA, alpha::Real,
           mend::GenericMERA; kwargs...)</code></pre><p>Given a &quot;tangent MERAs&quot; <code>mtan</code> and <code>mvec</code>, at base point <code>m</code>, transport <code>mvec</code> in the direction of <code>mtan</code> by distance <code>alpha</code>. This is done tensor-by-tensor, i.e. each tensor is transported along its respective Stiefel/Grassmann tangent.</p><p><code>mend</code> is the endpoint on the manifold, i.e. the result of retracting by <code>alpha</code> in the direction of <code>mtan</code>. The additional keyword argument are passed on to the respective <code>TensorKitManifolds</code> function.</p><p>See <code>TensorKitManifolds.transport!</code> for more details.</p><p>See also: <a href="#TensorKitManifolds.retract"><code>retract</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L1024-L1039">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKitManifolds.inner" href="#TensorKitManifolds.inner"><code>TensorKitManifolds.inner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">inner(m::GenericMERA, m1::GenericMERA, m2::GenericMERA; metric=:euclidean)</code></pre><p>Given two tangent MERAs <code>m1</code> and <code>m2</code>, both at base point <code>m</code>, compute their inner product. This means the sum of the inner products of the individual tensors.</p><p>See <code>TensorKitManifolds.inner</code> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L937-L944">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.tensorwise_sum" href="#MERA.tensorwise_sum"><code>MERA.tensorwise_sum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tensorwise_sum(m1::T, m2::T) where T &lt;: GenericMERA</code></pre><p>Return a MERA for which each tensor is the sum of the corresponding tensors of <code>m1</code> and <code>m2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L923-L928">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MERA.tensorwise_scale" href="#MERA.tensorwise_scale"><code>MERA.tensorwise_scale</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tensorwise_scale(m::GenericMERA, alpha::Number)</code></pre><p>Scale all the tensors of <code>m</code> by <code>alpha</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mhauru/MERA.jl/blob/e68cb11e5d58fb40a5a96360b2b0af852ab10cea/src/genericmera.jl#L914-L918">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#MERA.BinaryLayer"><code>MERA.BinaryLayer</code></a></li><li><a href="#MERA.BinaryMERA"><code>MERA.BinaryMERA</code></a></li><li><a href="#MERA.GenericMERA"><code>MERA.GenericMERA</code></a></li><li><a href="#MERA.Layer"><code>MERA.Layer</code></a></li><li><a href="#MERA.ModifiedBinaryLayer"><code>MERA.ModifiedBinaryLayer</code></a></li><li><a href="#MERA.ModifiedBinaryMERA"><code>MERA.ModifiedBinaryMERA</code></a></li><li><a href="#MERA.SimpleLayer"><code>MERA.SimpleLayer</code></a></li><li><a href="#MERA.TernaryLayer"><code>MERA.TernaryLayer</code></a></li><li><a href="#MERA.TernaryMERA"><code>MERA.TernaryMERA</code></a></li><li><a href="#MERA.ascend"><code>MERA.ascend</code></a></li><li><a href="#MERA.ascended_operator"><code>MERA.ascended_operator</code></a></li><li><a href="#MERA.causal_cone_width"><code>MERA.causal_cone_width</code></a></li><li><a href="#MERA.densitymatrices"><code>MERA.densitymatrices</code></a></li><li><a href="#MERA.densitymatrix"><code>MERA.densitymatrix</code></a></li><li><a href="#MERA.densitymatrix_entropies"><code>MERA.densitymatrix_entropies</code></a></li><li><a href="#MERA.depseudoserialize"><code>MERA.depseudoserialize</code></a></li><li><a href="#MERA.descend"><code>MERA.descend</code></a></li><li><a href="#MERA.environment"><code>MERA.environment</code></a></li><li><a href="#MERA.expand_bonddim"><code>MERA.expand_bonddim</code></a></li><li><a href="#MERA.expand_internal_bonddim"><code>MERA.expand_internal_bonddim</code></a></li><li><a href="#MERA.expect"><code>MERA.expect</code></a></li><li><a href="#MERA.fixedpoint_densitymatrix"><code>MERA.fixedpoint_densitymatrix</code></a></li><li><a href="#MERA.get_layer"><code>MERA.get_layer</code></a></li><li><a href="#MERA.gradient"><code>MERA.gradient</code></a></li><li><a href="#MERA.inputspace"><code>MERA.inputspace</code></a></li><li><a href="#MERA.internalspace"><code>MERA.internalspace</code></a></li><li><a href="#MERA.layertype"><code>MERA.layertype</code></a></li><li><a href="#MERA.minimize_expectation"><code>MERA.minimize_expectation</code></a></li><li><a href="#MERA.num_translayers"><code>MERA.num_translayers</code></a></li><li><a href="#MERA.operatortype"><code>MERA.operatortype</code></a></li><li><a href="#MERA.outputspace"><code>MERA.outputspace</code></a></li><li><a href="#MERA.pseudoserialize"><code>MERA.pseudoserialize</code></a></li><li><a href="#MERA.random_MERA"><code>MERA.random_MERA</code></a></li><li><a href="#MERA.randomlayer"><code>MERA.randomlayer</code></a></li><li><a href="#MERA.release_transitionlayer"><code>MERA.release_transitionlayer</code></a></li><li><a href="#MERA.remove_symmetry"><code>MERA.remove_symmetry</code></a></li><li><a href="#MERA.replace_layer"><code>MERA.replace_layer</code></a></li><li><a href="#MERA.reset_storage"><code>MERA.reset_storage</code></a></li><li><a href="#MERA.scale_invariant_operator_sum"><code>MERA.scale_invariant_operator_sum</code></a></li><li><a href="#MERA.scalefactor"><code>MERA.scalefactor</code></a></li><li><a href="#MERA.scalingdimensions"><code>MERA.scalingdimensions</code></a></li><li><a href="#MERA.tensorwise_scale"><code>MERA.tensorwise_scale</code></a></li><li><a href="#MERA.tensorwise_sum"><code>MERA.tensorwise_sum</code></a></li><li><a href="#TensorKitManifolds.inner"><code>TensorKitManifolds.inner</code></a></li><li><a href="#TensorKitManifolds.projectisometric"><code>TensorKitManifolds.projectisometric</code></a></li><li><a href="#TensorKitManifolds.projectisometric!"><code>TensorKitManifolds.projectisometric!</code></a></li><li><a href="#TensorKitManifolds.retract"><code>TensorKitManifolds.retract</code></a></li><li><a href="#TensorKitManifolds.transport!"><code>TensorKitManifolds.transport!</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 7 September 2020 09:28">Monday 7 September 2020</span>. Using Julia version 1.6.0-DEV.849.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
